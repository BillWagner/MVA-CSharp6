Module 1:
===========================================================
This module shows some of the new features. I picked these
features first because they are easy to explain for 
simple use cases, and they should be good 'hooks' for the
audience.

Step one: Create the project, add an EvilGenius Class.
The first version of the EvilGenius class just has the 
three properties.

2: Let's add an override of ToString() so the Evil
Genius can announce himself to the world. Do this using
the classic syntax. Include creating an EvilGenius in
Main() and writing a console message.

3. Translate ToString() to an expression bodied member.
Discuss benefits.

4. In Main, replace Console.WriteLine with WriteLine
and a static using. Point out that you don't get a 
codefix for a static using. (Is that coming? Community
contribution?)  Add the static using statement. Point
out that intellisense knows to filter namespaces vs.
classes depending on the presence of the 'static' keyword
in the using statement.

Let's take a few moments to talk about both of these features.
Expression Bodied Members:
. Must be single expressions (not multi-line anonymous functions)
. Could be LINQ queries, which might be complex
. great for read only properties (which we will cover later.)

Static Usings:
. De clutter source. (We know WriteLine is likely in theConsole
class)
. Consider Math class, even System.String.
. Later, we'll discuss how static usings work with Extension 
methods.

Now, let's move on to the null coalescing operator

5. Change the henchman to a class (we will add more properties
and features later.) 

6. Change ToString so that it also prints out the name of the
henchman, if present. I really don't want to do all that 
typing to make it a classic style method, add if statements
and else clauses, depending on the presence of the henchman. 

After this change, let's finish by showing how you can handle
ownership issues where an element may or may not implement
IDisposable.

7,8. In module 1, let's make it a very simple method added to 
EvilGenius to 'replace' a henchman. Add the public RetireHenchman
method. Discuss alternatives, and show how the null coalescing
operator makes it easy to do the right thing, and safely 
handle possible disposable henchman.

===========================================================
Module 2:  Read Only Properties and Dictionary Initializers

Now, we make a couple changes to the EvilGenius class to 
make use of Read Only Property enhancement.

M2.1: Change Minion to a readonly only property with a 
backing field. Rename RetireMinion as ReplaceMinion, and
have it take a new minion. This means we can use 
Interlocked.Exchange to be completely thread safe when
the minion is replaced.






